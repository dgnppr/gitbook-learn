# 트랜잭션과 잠금


## 트랜잭션

- 논리적인 작업 셋을 모두 완벽하게 처리하거나, 또는 처리하지 못할 경우에는 아무것도 하지 않는 것을 보장하는 것 
  - 작업의 일부만 적용되는 현상(Partial Update)가 발생하지 않게 만들어주는 기능
- 잠금 VS 트랜잭션
  - 잠금은 동시성을 제어하기 위한 기능
  - 트랜잭션은 데이터의 정합성을 보장하기 위한 기능
- 격리 수준
  - 하나의 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지 결정하는 레벨
- 주의 사항
  - **`DBMS`의 커넥션과 동일하게 꼭 필요한 최소의 코드에만 적용하는 것이 좋다**
  - **네트워크 작업이 있는 경우에는 트랜잭션에서 배제해야 한다.**

<br>

### 트랜잭션 범위를 최소화 해야하는 이유

- MySQL은 클라이언트 요청마다 클라이언트 쓰레드(포그라운드 쓰레드)를 생성하는데, 트랜잭션이 길어질수록 이 쓰레드들이 시스템 리소스를 점유하게 되고, 결국 시스템이 느려지게 된다.
- 또한 트랜잭션이 길어지면, 쓰레드 풀에서 사용 가능한 쓰레드 수를 감소시킨다.
- 긴 트랜잭션은 데이터에 대한 락을 오랫동안 유지하게 될 수 있다.
- **트랜잭션이 진행되는 동안 InnoDB의 언두 로그에 트랜잭션 변경 사항을 추적하는데, 트랜잭션이 길어지면 언두 로그가 커지고, 디스크 공간을 더 많이 차지한다**
- **트랜잭션이 진행되는 동안, InnoDB는 변경된 데이터에 대한 스냅샷을 버퍼풀에 유지해야 하며, 변경된 페이지들은 트랜잭션이 커밋되거나 롤백될 때까지 버퍼 풀에 남아 있는다. 이는 메모리 사용량을 증가시킨다.**

<br><br><br><hr>

## MySQL 엔진 잠금

### 글로벌 락

- MySQL 서버 전체에 걸리는 락
  - MyISAM 이나 MEMORY 테이블에서 `mysqldump`로 백업을 받을 때 글로벌 락을 사용함
- 한 세션에서 글로벌 락을 획득하면 다른 세션에서 `SELECT` 쿼리를 제외한 대부분의 DDL, DML 쿼리를 글로벌 락이 해제될 떄까지 대기 상태로 남는다.
- 글로벌 락은 MySQL 서버의 모든 테이블에 영향을 주기 때문에, 가급적 사용하지 않는 것이 좋다.
- `InnoDB` 에서는 조금 더 가벼운 글로벌 락인 백업 락을 사용한다
  - 특정 세션에서 백업 락을 획득하면 모든 세션에서 테이블의 스키마나 사용자의 인증 관련 정보를 변경할 수 없다
  - 일반적인 테이블의 데이터 변경은 허용된다

<br>

### 테이블 락

- 개별 테이블 단위로 설정되는 잠금
- 명시적으로 특정 테이블의 락을 획득할 수 있는데, 특별한 상황이 아니라면 사용하지 않는 것이 좋다.
- MyISAM 이나 MEMORY 테이블에서는 데이터를 변경하는 쿼리를 실행하면 묵시적으로 테이블 락을 사용한다. 즉, 묵시적인 테이블 락은 쿼리가 실행되는 동안 자동으로 획득됐다가 쿼리가 완료된 후 자동 해제된다.
- **InnoDB 테이블에서는 테이블 락 대신에 테이블의 레코드 락을 사용하기 때문에 단순 데이터 변경 쿼리로 인해 묵시적인 테이블 락이 설정되지 않는다.**
  - 정확히는 대부분의 데이터 변경(DML) 쿼리에서는 무시되고 스키마를 변경하는 쿼리(DDL)의 경우에만 영향을 미친다.

<br>

### 네임드 락

- **네임드락은 락 대상이 테이블이나 레코드 또는 AUTO_INCREMENT 같은 DB 객체가 아니라 임의의 문자열에 대해 잠금을 설정한다.**
  - 단순하게 사용자가 지정한 문자열에 대해 획득하고 반납하는 잠금이다.
- MySQL 8.0 버전부터는 네임드락을 중접해서 사용할 수 있고, 현재 세션에서 획득한 네임드 락을 한 번에 모두 해제하는 기능도 추가됐다.

<br>

### 메타데이터 락

- **데이터베이스 객체의 이름이나 구조를 변경하는 경우에 획득하는 락**
- 명시적으로 획득하거나 해제할 수 있는 것이 아니고, `RENAME TABLE tab_a TO tab_b` 같이 테이블 이름을 변경하는 경우 자동으로 획득하는 잠금이다.
  - `RENAME`의 경우 원본 이름과 변경될 이름 두 개 한꺼번에 잠금을 설정한다


<br><br><br><hr>

## InnoDB 스토리지 엔진 잠금

### 레코드 락

- 레코드 자체만을 잠그는 락
- **중요한 점은 InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠근다**
  - 인덱스가 하나도 없는 테이블이더라도 내부적으로 자동 생성된 클러스터 인덱스를 사용해 잠금을 설정한다

<br>

### 갭락

- 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 락
- 갭 락은 레코드와 레코드 사이의 간격에 새로운 레코드가 생성(Insert) 되는 것을 제어한다
- 갭 락은 그 자체보다는 넥스트 키 락의 일부로 자주 사용된다.

<br>

### 넥스트 키 락

- 레코드 락과 갭 락을 합쳐 놓은 형태의 락
- **InnoDB의 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주목적이다.**
  - 의외로 넥스트 키 락과 갭 락으로 인해 데드락이 발생하거나 성능이 저하되는 경우가 많다.
  - **가능하다면 STATEMENT 포맷의 바이너리 로그를 ROW 포맷의 바이너리 로그로 바꿔서 넥스트 키 락이나 갭 락을 줄이는 것이 좋다.**

<br>

### 자동 증가 락

- `AUTO_INCREMENT` 칼럼이 사용된 테이블 수준의 잠금
  - 자동 증가락은 테이블에 단 하나만 존재한다
  - 명시적으로 획득하고 해제하는 방법은 없다
- `AUTO_INCREMENT` 칼럼이 사용된 테이블에 동시에 여러 레코드가 `INSERT` 될 경우, 저장되는 레코드는 중복되지 않고 저장된 순서대로 증가하는 일련번호를 가진다
- **자동 증가락은 INSERT 나 REPLACE 쿼리 문장과 같이 새로운 레코드를 저장하는 쿼리에서만 필요하며, UPDATE 나 DELETE 쿼리에서는 걸리지 않는다.**
- 트랜잭션과 관계없이 INSERT 나 REPLACE 쿼리가 실행될 때마다 자동 증가 락이 설정되고, 쿼리가 완료되면 자동으로 해제된다.

#### innodb_autoinc_lock_mode

- 0
  - 모든 INSERT 문장에 대해 자동 증가 락을 사용한다
- 1
  - MySQL 서버가 INSERT 되는 레코드의 건수를 정확히 예측할 수 있을 때는 자동 증가락을 사용하지 않고, 훨씬 가볍고 빠른 뮤텍스를 사용한다
  - 대량의 INSERT가 수행될 떄는 여러 개의 자동 증가 값을 한 번에 할당받아서 레코드에 사용한다.
  - 그래서 대량 INSERT 되는 레코드는 자동 증가 값이 누락되지 않고 연속되게 INSERT 되고, 한 번 할당 받은 자동 증가 값은 사용되지 못하면 폐기 된다.
  - 이 설정에서는 최소한 하나의 INSERT 문장으로 INSERT 되는 레코드는 연속된 자동 증가 값을 가진다.
- 2
  - 자동 증가 락을 걸지 않고 뮤텍스를 사용한다
  - 이 설정에서는 하나의 INSERT 문장으로 INSERT 되는 레코드라도 연속된 자동 증가 값을 보장하지는 않는다.

<br>

<br><br><br><hr>

## 인덱스 잠금

- InnoDB 락은 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 처리된다
- **변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락을 건다.**
- 테이블에 인덱스가 하나도 없다면 어떻게 될까?
  - **이러한 경우에는 텡이블을 풀스캔하면서 모든 레코드를 잠그게 된다.**

<br><br><br><hr>

## 격리 수준

- **여러 트랜잭션이 동시에 처리 될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지 결정하는 것이다.**
- 4개의 격리 수준이 있고, 뒤로 갈수록 각 트랜잭션의 데이터 격리 수준이 높아지고, 동시 처리 성능도 떨어지게 된다.
- 사실 SERIALIZABLE 격리 수준이 아니라면 크게 성능의 개선이나 저하는 발생하지 않는다.

### READ UNCOMMITTED

- DIRTY READ, NON-REPEATABLE READ, PHANTOM READ 등의 현상이 발생할 수 있다.
- **트랜잭션에서 변경한 내용이 COMMIT 되지 않았는데도 다른 트랜잭션에서 변경된 내용을 읽을 수 있다.**
- 정합성이 문제가 많은 격리 수준이다.

<br>

### READ COMMITTED

- NON-REPEATABLE READ, PHANTOM READ 등의 현상이 발생할 수 있다.
- 어느 트랜잭션에서 읽은 데이터의 값이 달라지는 현상이 발생한다.
- InnoDB의 경우 언두 영역으로 백업된 레코드에서 가져온다.
  - 즉, **어떤 트랜잭션에서 변경한 내용이 커밋되기 전까지는 다른 트랜잭션에서 변경된 내용을 볼 수 없다.**

<br>

### REPEATABLE READ

- MySQL 스토리지 엔진에서 기본으로 사용되는 격리 수준
- PHANTOM READ 등의 현상이 발생할 수 있다.
  - 없던 데이터가 생기는 현상
  - **`SELECT FOR UPDATE` 쿼리는 SELECT 하는 레코드에 쓰기 잠금을 걸어야 하는데, 언두 레코드에는 잠금을 걸 수 없다. 그래서 `SELECT FOR UPDATE` or `SELECT ... LOCK IN SHARE MODE`로 조회되는 레코드는 언두 영역의 변경 전 데이터를 가져오는 것이 아니라 현재 레코드의 값을 가져오게 되는 것이다.**
- 바이너리 로그를 가진 MySQL 서버에서는 최소 REPEATABLE READ 격리 수준 이상을 사용해야 한다.
- InnoDB 스토리지 엔진은 트랜잭션이 롤백될 가능성에 대비해 변경되기 전 레코드를 언두 공간에 백업해두고 실제 레코드 값을 변경한다
- **`REPEATABLE READ` 과 `READ `COMMITTED` 의 차이는 언두 영역에 백언된 레코드의 여러 버전 가운데 몇 번째 이전 버전까지 찾아 들어가느냐에 있다.**
  - `REPEATABLE READ` 격리 수준에서는 `MVCC`를 보장하기 위해서 실행 중인 트랜잭션 가운데 가장 오래된 트랜잭션 번호보다 앞선 언두 영역의 데이터는 삭제할 수 없다. 특정 트랜잭션 번호의 구간 내에서 백업된 언두 데이터가 보존되어야 한다.

<br>

### SERIALIZABLE

- 가장 단순하고 엄격한 격리 수준
- InnoDB 테이블에서는 순수한 SELECT 쿼리에 대해서는 아무런 레코드 잠금도 설정하지 않는다
  - **Non-locking consistent read 라는 말이 이 의미이다.**
- 하지만, 격리 수준을 `SERIALIZABLE`로 설정되면 일기 작업도 공유 잠금을 획득해야 한다.
- InnoDB 스토리지 엔진에서는 갭 락과 넥스트 키락 때문에 REPEATABLE READ 격리 수준에서도 이미 PHANTOM READ가 발생하지 않는다