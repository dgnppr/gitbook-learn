# InnoDB 스토리지 엔진

## 아키텍처

![https://dev.mysql.com/doc/refman/8.0/en/innodb-architecture.html](https://dev.mysql.com/doc/refman/8.0/en/images/innodb-architecture-8-0.png)

<hr>

## 특징

### [PK에 의한 클러스터링](https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html)

- InnoDB의 모든 테이블은 기본적으로 PK를 기준으로 클러스터링된다. 즉, PK 값 순서대로 디스크에 저장된다.
- PK(클러스터링) 인덱스가 자동 생성된다.
- 모든 세컨더리 인덱스는 레코드 주소 대신 PK 값을 논리적인 주소로 사용한다. 
  - PK를 통해서만 레코드에 접근 가능
  - PK를 통한 레인지 스캔 매우 빠름
- 클러스터링 때문에 쓰기 성능 저하

> `MyISAM` 스토리지 엔진에서는 클러스터링 키를 지원하지 않는다. PK는 유니크 제약을 가진 세컨더리 인덱스일 뿐이다.
> <br>
> `MyISAM` 테이블의 프라이머리키를 포함한 모든 인덱스는 물리적인 레코드의 주소 값(`ROWID`)를 가진다.

<hr>

### [외래키 지원](https://dev.mysql.com/doc/refman/8.0/en/create-table-foreign-keys.html)

- InnoDB 스토리지 엔진 레벨에서 지원하는 기능으로 `MyISAM`이나 `MEMORY` 테이블에서는 사용할 수 없음
- **부모, 자식 테이블 모두 해당 컬럼에 대한 인덱스 생성이 필요하고, 변경 시에는 반드시 부모, 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하므로 잠금이 여러 테이블로 전파되고, 그로 인해 데드락이 발생할 때가 많으므로 개발할 때 외래 키의 존재에 주의하는 것이 좋다.**

```SQL
SET foreign_key_checks = OFF;

-- // 작업 실행

SET foreign_key_checks = ON;
```

- `foreign_key_checks` 시스템 변수를 `OFF`로 설정하면 외래 키 관계애 대한 체크 작업을 일시적으로 멈출 수 있음
  - 멈추면 `ON DELETE CASCADE`와 `ON UPDATE CASCADE`도 무시하게 된다.  
  - 일시적으로 해제했다고 테이블 간의 관계가 깨진 상태로 그대로 유지해도 된다는 것을 의미하지 않음. 꼭 데이터 일관성을 맞춰줘야 한다.
- `foreign_key_checks` 시스템 변수는 적용 범위를 글로벌과 세션 모두 설정 가능한 변수이다. 작업을 할 때는 현재 작업을 실행하는 세션에서만 외래 키 체크 기능을 멈추게 해야한다.
  - `SESSION` 키워드를 명시하지 않으면 자동으로 현재 세션의 설정만 변경한다.


<hr>

### [MVCC](https://dev.mysql.com/doc/refman/8.0/en/innodb-multi-versioning.html)

- `InnoDB` 스토리지 엔진은 트랜잭션의 격리 수준을 위해 잠금을 사용하지 않고 읽기 작업을 수행한다.
  - 즉, 잠금을 사용하지 않고 하나의 레코드에 대해 여러 개의 버전이 동시에 관리될 수 있다는 것을 의미한다.
- `InnoDB`는 [언두 로그](https://dev.mysql.com/doc/refman/8.0/en/innodb-undo-tablespaces.html)를 사용해 이 기능을 구현한다.

<br>

#### 언두 로그 영역을 활용한 MVCC

![https://www.youtube.com/watch?v=vQFGBZemJLQ](https://github.com/dragonappear/learn/assets/89398909/3a14f761-519e-4770-b22a-1a6928428535)

`UPDATE` 쿼리가 실행되면 커밋 실행 여부와 관계없이 InnoDB 버퍼풀은 새로운 값으로 업데이트 된다. 디스크의 데이터 파일에는 체크포인트나 InnoDB의 Write 스레드에 의해 새로운 값으로 업데이트 되었을수도 있고 아닐 수도 있다.

아직 커밋이나 롤백이 되지 않은 상태에서 다른 사용자가 작업 중인 레코드를 조회하면 어떻게 데이터가 조회될까? 이 질문의 답은 MySQL 서버의 시스템 변수(`transaction_isolation`)에 설정된 격리 수준에 따라 달라진다.
 
- `READ_UNCOMMITTED`: InnoDB 버퍼 풀이 현재 가지고 있는 변경된 데이터를 읽어서 반환. 즉, 커밋됐든 아니든 변경된 상태의 데이터를 반환한다
- `READ_COMMITTED`나 그 이상의 격리 수준인 경우 : 아직 커밋되지 않았기 때문에 InnoDB 버퍼 풀이나 데이터 파일에 있는 내용 대신 변경되기 이전의 내용을 보관하고 있는 언두 영역의 데이터를 반환

<br>

#### 언두 영역 데이터 삭제는 언제될까?

- 롤백을 실행하면 `InnoDB`는 언두 영역에 있는 백업된 데이터를 InnoDB 버퍼풀로 다시 복구하고, 언두 영역의 내용을 삭제해버린다. 
- 커밋이 되었다고 해서 언두 영역의 백업 데이터가 항상 바로 삭제되는 것은 아니다. 
- 언두 영역을 필요로 하는 트랜잭션이 더는 없을 때 비로소 삭제된다.

> 트랜잭션이 길어지면 언두에서 관리하는 예전 데이터가 삭제되지 못하고 오랫동안 관리되어야 하며, 언두 영역이 저장되는 시스템 테이블스페이스의 공간이 많이 늘어나는 상황이 발생할 수 있다.

<hr>

### [잠금 없는 일관된 읽기](https://dev.mysql.com/doc/refman/8.0/en/innodb-consistent-read.html)

- 격리 수준이 `SERIALIZABLE`이 아닌 `READ_COMMITTED`, `REPEATABLE_READ`, `READ_UNCOMMITTED`인 수준인 경우에 `INSERT`와 연결되지 않은 **순수한 읽기 작업은 다른 트랜잭션의 변경 작업과 관계없이 항상 잠금을 대기하지 않고 바로 실행된다**
- `InnoDB`에서는 변경되기 전의 데이터를 읽기 위해 언두 로그를 사용한다

<hr>

### [자동 데드락 감지](https://dev.mysql.com/doc/refman/8.0/en/innodb-deadlocks.html)

- InnoDB 스토리지 엔진은 내부적으로 잠금이 데드락 상태에 있는지 체크하기 위해 `Wait-for List`를 사용한다.
- InnoDB 스토리지 엔진은 데드락 감지 스레드로 주기적으로 잠금 대기 그래프를 검사해서 데드락에 빠진 트랜잭션을 찾아서 그 중 하나를 강제 종료 한다.
- 어느 트랜잭션을 먼저 강제 종료할 것인지를 판단하는 기준은 트랜잭션의 언두 로그 양이며, 언두 로그 레코드를 더 적게 가진 트랜잭션이 일반적으로 롤백의 대상이 된다
- 동시 처리 스레드가 매우 많아지거나 각 트랜잭션이 가진 잠금의 개수가 많아지면 데드락 감지 스레드가 느려진다. 왜냐하면 잠금 목록을 검사해야 하기 때문에 잠금 상태가 변경되지 않도록 잠금 목록이 저장된 리스트(잠금 테이블)에 새로운 잠금을 걸고 데드락 스레드를 찾기 때문이다.
  - `innodb_deadlock_detect`를 `OFF`로 설정하면 데드락 감지 스레드는 더 동작하지 않는다. 이렇게 되면 데드락이 발생한 트랜잭션들은 무한정 대기하게 될 것이다. 
  - 이럴 경우, `innodb_lock_wait_timeout` 시스템 변수를 활성화해서 데드락 상황에서 일정 시간이 지나면 자동으로 요청이 실패하고 에러 메시지를 반환하게 한다.
    - 초 단위 설정 가능
    - 잠금을 설정한 시간 동안 획득하지 못하면 쿼리는 실패하고 에러 반환
    - 데드락 감지 스레드가 부담되어 `innodb_deadlock_detect`를 `OFF`로 설정해서 비활성하는 경우라면 `innodb_lock_wait_timeout` 기본값인 50초보다 훨씬 낮은 시간으로 변경해서 사용하자.

> MySQL 엔진에서 관리되는 테이블 잠금(`LOCK TABLES` 명령으로 잠긴 테이블)은 볼 수가 없어서 데드락 감지가 불확실할 수 있는데, `innodb_table_lock` 시스템 변수를 활성화하면 InnoDB 스토리지 엔진 내부의 레코드 잠금뿐만 아니라 테이블 레벨의 잠금까지 감지할 수 있다.
> <br>
> **특별한 이유가 없다면 `innodb_table_locks` 시스템 변수를 활성화하자**.

<hr>

### [자동화된 장애 복구](https://dev.mysql.com/doc/refman/8.0/en/forcing-innodb-recovery.html)

`InnoDB`에는 손실이나 장애로부터 데이터를 보호하기 위한 여러가지 메너니즘이 탑재되어 있음.

MySQL 서버가 시작될 때 완료되지 못한 트랜잭션이나 디스크에 일부만 기록된(Partial Write) 데이터 페이지 등에 대한 일련의 복구 작업이 자동으로 진행된다.

**InnoDB 데이터 파일은 기본적으로 MySQL 서버가 시작될 때 항상 자동 복구를 수행한다.**

이 단계에서 자동으로 복구될 수 없는 손상이 있다면 자동 복구를 멈추고 MySQL 서버는 종료된다.
- 이때는 `innodb_force_recovery` 시스템 변수를 활성화해서 MySQL 서버를 시작하면 된다.
- 이 설정값은 MySQL 서버가 시작될 때 InnoDB 스토리지 엔진이 데이터 파일이나 로그 파일의 손상 여부 검사 과정을 선별적으로 진행할 수 있게 한다
- `innodb_force_recovery`에 대한 설정값(1~6)은 공식문서를 통해 확인하자. `innodb_force_recovery` 설정값이 `0`이 아닌 복구 모드에서는 `SELECT` 이외의 쿼리는 수행할 수 없다.

MySQL 서버가 가동되고 InnoDB 테이블이 인식된다면 `mysqldump`를 이용해 데이터를 가능한 만큼 백업하고 그 데이터로 MySQL 서버의 DB와 테이블을 다시 생성하는 것이 좋다.

<hr>

### [InnoDB 버퍼 풀](https://dev.mysql.com/doc/refman/8.0/en/innodb-buffer-pool.html)

- `InnoDB`에서 가장 핵심적인 부분으로, 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해두는 공간
- 쓰기 작업을 지연시켜 일괄 적업으로 처리할 수 있게 해주는 버퍼 역할
  - 변경된 데이터를 모아서 처리하면 랜덤 IO 작업 횟수를 줄일 수 있다.

#### 버퍼 풀 크기 설정

- 운영체제와 각 클라이언트 스레드가 사용할 메모리도 충분히 고려해서 설정해야 한다.

<hr>

### 체인지 버퍼

- 레코드가 업데이트되거나 삭제될 때 인덱스를 업데이트하는 작업도 수해오디어야 하는데, 인덱스를 업데이트하는 작업은 랜덤 I/O 작업이 필요하므로, 테이블에 인덱스가 많다면 많은 자원을 소모하게 된다.
- 그래서 InnoDB는 변경해야 할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행하지만 그렇지 않다면 디스크로부터 읽어와서 업데이트해야 한다면 이를 즉시 실행하지 않고 임시 공간에 저장해두고 바로 사용자에게 결과를 반환하는 형태로 성능을 향상시킨다.
  - 이 때 사용되는 공간이 체인지 버퍼이다.
- **사용자에게 결과를 전달하기 전에 반드시중복 여부를 체크해야 하는 프라이머리 키나 유니크 인덱스는 사용할 수 없다.**
- 체인지 버퍼에 임시로 저장된 인덱스 레코드 조각은 이후 백그라운드 스레드(체인지 버퍼 머지 스레드)에 의해 병합된다.
- `innodb_change_buffering`이라는 시스템 변수를 사용하여 작업 종류 별로 체인지 버퍼를 활성화할 수 있다.
- 체인지 버퍼는 기본적으로 InnoDb 버퍼 풀로 설정된 메모리 공간의 25%까지 사용할 수 있게 설정되어 있다.


<hr>

## Ref

- https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html
- https://www.youtube.com/watch?v=vQFGBZemJLQ