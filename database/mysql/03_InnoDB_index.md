# 인덱스

<br>

## I/O

- 디스크를 `HDD`로 사용할 경우 랜덤 I/O가 많아지면 디스크 원판을 돌리는 헤드가 움직이는 횟수가 많아지기 때문에 성능이 떨어진다. 
  - 디스크를 `SSD`로 사용할 경우에도 랜덤 I/O가 많아지면 성능이 떨어진다. 
- `SSD`는 `HDD`와 달리 랜덤 I/O 성능이 `HDD`에 비해 높지만, `HDD`에 비해 랜덤 I/O 성능이 높다고 해서 랜덤 I/O가 많아져도 성능이 떨어지지 않는 것은 아니다.
- **데이터베이스의 성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 관건이다. 정확하게는 쿼리를 튜닝할 때 랜덤 I/O 자체를 줄여주는 것이 관건이다.**

> 인덱스 레인지 스캔은 주로 랜덤 I/O를 사용하며, 풀 테이블 스캔은 주로 순차 I/O를 사용한다. 그래서 큰 테이블의 레코드 대부분을 읽는 작업에서는 인덱스를 사용하지 않고 풀 테이블 스캔을 유도할 수도 있다.

<br><br>

## 인덱스

- 칼럼의 값과 해당 레코드가 저장된 주소를 key-value 형태로 저장하는 자료구조
- 최대한 빠르게 찾아갈 수 있게 정렬되어 있다.
  - 정렬을 위해 INSERT, UPDATE, DELETE 시에 추가 작업이 필요하다
- **결론적으로 인덱스는 데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하고 데이터의 조회(SELECT) 성능을 높이는 자료구조이다.**
  - SELECT 쿼리의 WHERE 조건절에 사용되는 칼럼이라고 해서 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고 인덱스의 크기가 커져서 인덱스의 성능도 떨어진다.

<br><br>

## B-tree 인덱스

### 구조 및 특성

- 인덱스의 키 값은 모두 정렬되어 있으나, 데이터 파일의 레코드는 정렬되어 있지 않고 임의의 순서로 저장되어 있다.
    - 인덱스는 테이블의 키 컬럼만 가지고 있고 나머지 컬럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야 한다.
    - 인덱스의 리프 노드가 데이터 파일에 있는 레코드의 주소를 가진다.
- 데이터 파일의 레코드는 INSERT 된 순서대로 저장되지는 않는다.
  - 테이블의 레코드를 전혀 삭제하거나 변경하지 않고 INSERT 만 수행하면 맞을수도 있다.
  - 레코드가 삭제되어 빈 공간이 생기면 그 다음의 INSERT 는 가능한 삭제된 공간을 재활용하도록 설계되어 있다.
  - **InnoDB 테이블에서는 레코드가 클러스터링되어 디스크에 저장되므로 기본적으로 프라이머리 키 순서로 정렬되어 저장된다.**
- **InnoDB 스토리지 엔진에서는 프라이머리 키가 ROWID 역할을 수행한다. 즉, 프라이머리 키를 주소처럼 사용한다.**
  - **모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해 반드시 프라이머리 키를 저장하고 있는 인덱스를 한 번 더 읽어야 한다.**

<br>

### 인덱스 키 추가 및 삭제

- 추가: 리프 노드에 저장된다. 
    - 리프 노드가 차면 [재조정](../../data-structure/tree/00_btree.md)을 수행한다.
    - InnoDB 스토리지 엔진은 인덱스 키 추가 작업을 체인지 버퍼를 이용하여 지연시킬 수 있다.
    - 프라이머리 키나 유니크 인덱스의 경우 중복 체크가 필요하기 때문에 지연하지 않고 바로 추가하거나 삭제한다
- **삭제**: 리프를 찾고 삭제 마크만 하면 작업이 완료된다. 삭제 마킹된 인덱스 키 공간은 방치하거나 재활용할 수 있다.
  - 인덱스 마킹 작업 또한 디스크 쓰기가 필요하고, 이 또한 지연 처리가 가능하다.
- **변경**: 키 삭제를 한 후 다시 새로운 키 값을 추가하는 형태로 처리된다.
- **검색**: 인덱스를 이용한 검색은 100% 일치 또는 값의 앞 부분만 일치하는 경우에 사용할 수 있다.
  - 부등호 비교 조건에서도 인덱스를 활용할 수 있지만
  - 인덱스를 구성하는 키 값의 뒷부분만 검색하는 용도로는 사용할 수 없다.
  - 또한 인덱스의 키 값에 변형이 가해진 후 비교 되는 경우도 사용할 수 없다. (ex: 함수나 연산 수행 결과로 정렬하거나 검색하는 작업 등)

<br>

### InnoDB 잠금

- InnoDB 테이블에서 지원하는 레코드 잠금이나 넥스트 키락(갭락)은 검색을 수행한 **인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현되어 있다.**
  - UPDATE, DELETE, SELECT ... FOR UPDATE 등의 작업을 수행할 때는 검색을 수행한 인덱스를 잠그는 것이 아니라 테이블의 레코드를 잠근다.
- **테이블에 적절히 사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠근다. 심지어 모든 레코드를 잠글 수 있다.**

<br><br>

## 인덱스 키 값의 크기

- InnoDB 스토리지 엔진은 디스크에 데이터를 저장하는 가장 기본 단위를 페이지(or 블록)이라고 하고, 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위가 된다.
  - InnoDB 스토리지 엔진의 버퍼 풀에서 데이터럴 버퍼링하는 기본 단위이기도 함
- 인덱스도 결국은 페이지 단위로 관리된다.
- **MySQL 의 B-tree 는 인덱스의 페이지 크기와 키 값의 크기에 따라 자식 노드 개수가 결정된다.**
  - `innodb_page_size` 시스템 변수로 페이지 크기를 설정할 수 있다. 기본값 16KB
- 인덱스 페이지 크기를 (인덱스 키 크기 + 자식 노드 주소) 로 나누면 인덱스 키의 개수를 구할 수 있는데, 
  - **키 값이 커지면 인덱스 페이지에 있는 인덱스 키 개수가 적어지고 결국에 디스크 I/O 횟수가 늘어난다.**
  - 인덱스 키 값이 커지면 인덱스 키를 비교하는 연산 비용도 커진다.
  - 또한, 인덱스 키 값이 커지면 인덱스를 구성하는 모든 칼럼이 메모리에 올라가지 못하고 디스크에서 읽어와야 하는 경우도 늘어난다.
    - InnoDB 버퍼풀의 크기는 제한적이기 때문이다.

<br><br>

## B-tree 깊이

- B-tree 의 깊이는 디스크 I/O 횟수와 직결된다. 인덱스 키가 커지면 인덱스 키 개수가 줄어들기 때문이다.
  - 인덱스 키가 커지면 같은 레코드 건수라고 하더라도 깊이가 깊어지고 디스크 I/O 횟수가 늘어난다.
- **인덱스 키 값의 크기는 가능하면 작게 만드는 것이 좋다.**

<br><br>

## 선택도(기수성)

- 인덱스에서 선택도는 모든 인덱스 키 값 가운데 유니크한 값의 수를 의미한다
- 인덱스 키 값 가운데 중복된 값이 많아지면 많아질수록 기수성은 낮아지고 동시에 선택도 또한 떨어진다.
- 인덱스는 선택도가 높을수록 검색 대상이 줄어들기 때문에 빠르게 처리된다.
- 선택도가 좋지 않더라도 정렬이나 그루핑과 같은 작업을 할 때는 인덱스를 만드는 것이 훨씬 나은 경우도 많다.

```SQL
SELECT *
FROM tb_test
WHERE country = 'Korea' AND city = 'Seoul';
```
tb_test 라는 테이블이 있고, 전체 레코드 건수가 1만건이라고 가정해보자.

- 케이스 A: 칼럼이 유니크한 값의 개수가 10개
- 케이스 B: 칼럼이 유니크한 값의 개수가 1000개

A,B 케이스 모두 실제 모든 조건을 만족하는 레코드는 1건의 레코드가 있다고 가정했을 때,

A 케이스의 경우 1건의 레코드를 위해 불필요한 999건의 레코드를 더 읽어야 한다. (선택도 10000/10)

B 케이스의 경우 1건의 레코드를 위해 불필요한 9건의 레코드를 더 읽어야 한다. (선택도 10000/1000)

**유니크한 값의 개수는 인덱스나 쿼리의 효율성에 큰 영향을 미친다.**

<br><br>

## 읽어야 하는 레코드의 건수

- 일반적인 DBMS의 옵티마이저에서는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배 정도 비용이 더 많이 드는 작업이라고 예측한다.
- **즉, 인덱스를 통해 읽어야 할 레코드의 건수가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고 테이블을 모두 직접 읽어서 필요한 레코드만 가려내는 방식이 더 효율적일 것이다.**

<br><br>

## 스캔

### 인덱스 레인지 스캔

<br>

### 인덱스 풀 스캔

<br>

### 루스 인덱스 스캔

<br>

### 인덱스 스킵 스캔

<br><br>

## Ref

- https://www.youtube.com/watch?v=liPSnc6Wzfk