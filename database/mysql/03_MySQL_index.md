# 인덱스

<br>

## I/O

- 디스크를 `HDD`로 사용할 경우 랜덤 I/O가 많아지면 디스크 원판을 돌리는 헤드가 움직이는 횟수가 많아지기 때문에 성능이 떨어진다. 
  - 디스크를 `SSD`로 사용할 경우에도 랜덤 I/O가 많아지면 성능이 떨어진다. 
- `SSD`는 `HDD`와 달리 랜덤 I/O 성능이 `HDD`에 비해 높지만, `HDD`에 비해 랜덤 I/O 성능이 높다고 해서 랜덤 I/O가 많아져도 성능이 떨어지지 않는 것은 아니다.
- **데이터베이스의 성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 관건이다. 정확하게는 쿼리를 튜닝할 때 랜덤 I/O 자체를 줄여주는 것이 관건이다.**

> 인덱스 레인지 스캔은 주로 랜덤 I/O를 사용하며, 풀 테이블 스캔은 주로 순차 I/O를 사용한다. 그래서 큰 테이블의 레코드 대부분을 읽는 작업에서는 인덱스를 사용하지 않고 풀 테이블 스캔을 유도할 수도 있다.

<br><br>

## 인덱스

- 칼럼의 값과 해당 레코드가 저장된 주소를 key-value 형태로 저장하는 자료구조
- 최대한 빠르게 찾아갈 수 있게 정렬되어 있다.
  - 정렬을 위해 INSERT, UPDATE, DELETE 시에 추가 작업이 필요하다
- **결론적으로 인덱스는 데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하고 데이터의 조회(SELECT) 성능을 높이는 자료구조이다.**
  - SELECT 쿼리의 WHERE 조건절에 사용되는 칼럼이라고 해서 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고 인덱스의 크기가 커져서 인덱스의 성능도 떨어진다.

<br><br>

## B-tree 인덱스

### 구조 및 특성

- 인덱스의 키 값은 모두 정렬되어 있으나, 데이터 파일의 레코드는 정렬되어 있지 않고 임의의 순서로 저장되어 있다.
    - 인덱스는 테이블의 키 컬럼만 가지고 있고 나머지 컬럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야 한다.
    - 인덱스의 리프 노드가 데이터 파일에 있는 레코드의 주소를 가진다.
- 데이터 파일의 레코드는 INSERT 된 순서대로 저장되지는 않는다.
  - 테이블의 레코드를 전혀 삭제하거나 변경하지 않고 INSERT 만 수행하면 맞을수도 있다.
  - 레코드가 삭제되어 빈 공간이 생기면 그 다음의 INSERT 는 가능한 삭제된 공간을 재활용하도록 설계되어 있다.
  - **InnoDB 테이블에서는 레코드가 클러스터링되어 디스크에 저장되므로 기본적으로 프라이머리 키 순서로 정렬되어 저장된다.**
- **InnoDB 스토리지 엔진에서는 프라이머리 키가 ROWID 역할을 수행한다. 즉, 프라이머리 키를 주소처럼 사용한다.**
  - **모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해 반드시 프라이머리 키를 저장하고 있는 인덱스를 한 번 더 읽어야 한다.**

<br>

### 인덱스 키 추가 및 삭제

- 추가: 리프 노드에 저장된다. 
    - 리프 노드가 차면 [재조정](../../data-structure/tree/00_btree.md)을 수행한다.
    - InnoDB 스토리지 엔진은 인덱스 키 추가 작업을 체인지 버퍼를 이용하여 지연시킬 수 있다.
    - 프라이머리 키나 유니크 인덱스의 경우 중복 체크가 필요하기 때문에 지연하지 않고 바로 추가하거나 삭제한다
- **삭제**: 리프를 찾고 삭제 마크만 하면 작업이 완료된다. 삭제 마킹된 인덱스 키 공간은 방치하거나 재활용할 수 있다.
  - 인덱스 마킹 작업 또한 디스크 쓰기가 필요하고, 이 또한 지연 처리가 가능하다.
- **변경**: 키 삭제를 한 후 다시 새로운 키 값을 추가하는 형태로 처리된다.
- **검색**: 인덱스를 이용한 검색은 100% 일치 또는 값의 앞 부분만 일치하는 경우에 사용할 수 있다.
  - 부등호 비교 조건에서도 인덱스를 활용할 수 있지만
  - 인덱스를 구성하는 키 값의 뒷부분만 검색하는 용도로는 사용할 수 없다.
  - 또한 인덱스의 키 값에 변형이 가해진 후 비교 되는 경우도 사용할 수 없다. (ex: 함수나 연산 수행 결과로 정렬하거나 검색하는 작업 등)

<br>

### InnoDB 잠금

- InnoDB 테이블에서 지원하는 레코드 잠금이나 넥스트 키락(갭락)은 검색을 수행한 **인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현되어 있다.**
  - UPDATE, DELETE, SELECT ... FOR UPDATE 등의 작업을 수행할 때는 검색을 수행한 인덱스를 잠그는 것이 아니라 테이블의 레코드를 잠근다.
- **테이블에 적절히 사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠근다. 심지어 모든 레코드를 잠글 수 있다.**

<br><br>

## 인덱스 키 값의 크기

- InnoDB 스토리지 엔진은 디스크에 데이터를 저장하는 가장 기본 단위를 페이지(or 블록)이라고 하고, 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위가 된다.
  - InnoDB 스토리지 엔진의 버퍼 풀에서 데이터럴 버퍼링하는 기본 단위이기도 함
- 인덱스도 결국은 페이지 단위로 관리된다.
- **MySQL 의 B-tree 는 인덱스의 페이지 크기와 키 값의 크기에 따라 자식 노드 개수가 결정된다.**
  - `innodb_page_size` 시스템 변수로 페이지 크기를 설정할 수 있다. 기본값 16KB
- 인덱스 페이지 크기를 (인덱스 키 크기 + 자식 노드 주소) 로 나누면 인덱스 키의 개수를 구할 수 있는데, 
  - **키 값이 커지면 인덱스 페이지에 있는 인덱스 키 개수가 적어지고 결국에 디스크 I/O 횟수가 늘어난다.**
  - 인덱스 키 값이 커지면 인덱스 키를 비교하는 연산 비용도 커진다.
  - 또한, 인덱스 키 값이 커지면 인덱스를 구성하는 모든 칼럼이 메모리에 올라가지 못하고 디스크에서 읽어와야 하는 경우도 늘어난다.
    - InnoDB 버퍼풀의 크기는 제한적이기 때문이다.

<br><br>

## B-tree 깊이

- B-tree 의 깊이는 디스크 I/O 횟수와 직결된다. 인덱스 키가 커지면 인덱스 키 개수가 줄어들기 때문이다.
  - 인덱스 키가 커지면 같은 레코드 건수라고 하더라도 깊이가 깊어지고 디스크 I/O 횟수가 늘어난다.
- **인덱스 키 값의 크기는 가능하면 작게 만드는 것이 좋다.**

<br><br>

## 선택도(기수성)

- 인덱스에서 선택도는 모든 인덱스 키 값 가운데 유니크한 값의 수를 의미한다
- 인덱스 키 값 가운데 중복된 값이 많아지면 많아질수록 기수성은 낮아지고 동시에 선택도 또한 떨어진다.
- 인덱스는 선택도가 높을수록 검색 대상이 줄어들기 때문에 빠르게 처리된다.
- 선택도가 좋지 않더라도 정렬이나 그루핑과 같은 작업을 할 때는 인덱스를 만드는 것이 훨씬 나은 경우도 많다.

```SQL
SELECT *
FROM tb_test
WHERE country = 'Korea' AND city = 'Seoul';
```
tb_test 라는 테이블이 있고, 전체 레코드 건수가 1만건이라고 가정해보자.

- 케이스 A: 칼럼이 유니크한 값의 개수가 10개
- 케이스 B: 칼럼이 유니크한 값의 개수가 1000개

A,B 케이스 모두 실제 모든 조건을 만족하는 레코드는 1건의 레코드가 있다고 가정했을 때,

A 케이스의 경우 1건의 레코드를 위해 불필요한 999건의 레코드를 더 읽어야 한다. (선택도 10000/10)

B 케이스의 경우 1건의 레코드를 위해 불필요한 9건의 레코드를 더 읽어야 한다. (선택도 10000/1000)

**유니크한 값의 개수는 인덱스나 쿼리의 효율성에 큰 영향을 미친다.**

<br><br>

## 읽어야 하는 레코드의 건수

- 일반적인 DBMS의 옵티마이저에서는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배 정도 비용이 더 많이 드는 작업이라고 예측한다.
- **즉, 인덱스를 통해 읽어야 할 레코드의 건수가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고 테이블을 모두 직접 읽어서 필요한 레코드만 가려내는 방식이 더 효율적일 것이다.**

<br><br>

## 스캔

### 인덱스 레인지 스캔

```SQL
SELECT *
FROM employees
WHERE first_name BETWEEN 'A' AND 'B';
```

- 검색해야할 인덱스의 범위가 결정됐을 때 사용하는 방식
- 시작해야할 위치를 찾으면 그때부터는 리프 노드의 레코드만 순서대로 읽으면 된다
- 인덱스를 구성하는 컬럼의 정순 또는 역순으로 정렬된 상태로 레코드를 가져온디. 인덱스 자체가 정렬되어 있기 때문이다.
- 인덱스의 리프 노드에서 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 가져오는 것이 필요하다
  - 레코드 한 건 한 건단위로 랜덤 I/O 발생

> **커버링 인덱스**
> <br>
> 디스크의 레코드를 읽지 않고 인덱스에 있는 데이터만 조회할 때 커버링 인덱스를 사용한다고 한다. 디스크의 레코드를 읽지 않아도 된다.

<br>

### 인덱스 풀 스캔

- 인덱스 처음부터 끝까지 모두 읽는 방식
  - 쿼리의 조건절에 사용된 컬럼이 인덱스의 첫 번째 칼럼이 아닌 경우 인덱스 풀 스캔 방식이 사용된다.
  - ex) 인덱스(A,B,C) 칼럼 순서로 만들어졌는데 쿼리의 조건절은 B,C 컬럼으로 검색하는 경우
- 인덱스 리프 노드의 제일 앞 또는 제일 뒤로 이동한 후, 인덱스의 리프 노드를 연결하는 링크드 리스트를 따라서 처음부터 끝까지 스캔한다.
- 인덱스 레인지 스캔보다는 빠르지 않지만 테이블 풀 스캔보다는 효율적이다

<br>

### 루스 인덱스 스캔

- 인덱스 레인지 스캔과 비슷하게 동작하지만 중간에 필요치 않은 인덱스 키 값은 무시하고 다음으로 넘어가는 형태로 처리한다.
  - 일반적으로 GROUP By 또는 집합 합수 가운데 MAX() 또는 MIN() 함수에 대해 최적화를 하는 경우에 사용된다

```SQL
SELECT dept_no, MIN(emp_no)
FROM dept_emp
WHERE dep_no BETWEEN 'd001' AND 'd002'
GROUP BY dept_no;
```

dept_no 와 emp_no 라는 두 개의 컬럼으로 인덱스가 생성되어 있을 때, 위 쿼리는 dept_no 컬럼으로 인덱스를 검색하고 emp_no 컬럼은 무시하고 다음으로 넘어가는 형태로 처리된다.

<br>

### 인덱스 스킵 스캔

```SQL
EXPLAIN 
SELECT gender, birth_date
FROM emplyoess
WHERE birth_date>='1965-02-01';
```

인덱스가 (gender, birth_date)로 구성되어 있을때 인덱스 스킵 스캔을 사용하지 않으면 인덱스 풀 스캔이 이뤄질 것이다.

MySQL 옵티마이저는 우선 gender 컬럼에서 유니크한 값을 모두 조회해서 주어진 쿼리에 gender 컬럼의 조건을 추가해서 쿼리를 다시 실행하는 형태로 처리한다

`SELECT gender, birth_date FROM emplyoess WHERE gender='M' birth_date>='1965-02-01';`

`SELECT gender, birth_date FROM emplyoess WHERE gender='F' birth_date>='1965-02-01';`


인덱스 스킵은 `WHERE` 조건절에 조건이 없는 인덱스의 선행 컬럼의 유니크한 값의 개수가 적어야하고, 쿼리가 인덱스에 존재하는 컬럼만으로 처리 가능해야 하는 단점이 있다.
- 유니크한 값의 개수가 매우 많다면 인덱스에서 스캔해야할 시작 지점을 검색하는 작업이 많이 필요해진다.
- **그래서 인덱스 스킵 스캔은 인덱스의 선행 컬럼이 가진 유니크한 값의 개수가 소량일 때만 적용 가능한 최적화이다.**

<br><br>

## 다중 컬럼 인덱스

- 인덱스는 정렬되어있다.
- 인덱스가 다중 컬럼으로 구성되어 있다면, 첫 번째 컬럼을 기준으로 정렬되어 있고, 첫 번째 컬럼의 값이 같은 경우에는 두 번째 컬럼을 기준으로 정렬되어 있다.
  - 첫 번째, 두 번째 컬럼이 같은 경우에는 세 번째 컬럼을 기준으로 정렬되어 있다.
- **다중 컬럼 인덱스에서는 인덱스 내에서 각 컬럼의 위치(순서)가 매우 중요하다.**

<br><br>

## 인덱스 스캔 방향

- 인덱스가 오름차순으로 생성되었다고 해서 그 인덱스를 오름차순으로만 읽을 수 있다는 것은 아니다.
  - **인덱스를 어느 방향으로 읽을지는 쿼리에 따라 옵티마이저가 실시간으로 만들어내는 실행 계획에 따라 결정된다.**

```SQL
SELECT *
FROM employees
ORDER BY first_name DESC
LIMIT 1;
```

first_name 오름차순으로 생성된 인덱스에서 해당 쿼리를 실행했을 때, 인덱스를 역순으로 접근해서 첫 번째 레코드만 읽어온다.

### 인덱스 스캔 방향의 중요성

`InnoDB`에서 내부적으로  인덱스 역순 스캔이 인덱스 정순 스캔에 비해 느리다. 이유는 2가지가 있다

1. 페이지 잠금이 인덱스 정순 스캔에 적합한 구조
2. 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조

**따라서 인덱스 정렬 방향에 따라서 인덱스 스캔 방향을 정해야 한다.**

> 많은 쿼리가 인덱스의 앞쪽 또는 뒤쪽만 집중적으로 읽어서 인덱스의 특정 페이지 잠금이 병목이 될 것으로 예상된다면 쿼리에서 자주 사용되는 정렬 순서대로 인덱스를 생성하는 것이 잠금 병목 현상을 완화하는데 도움이 될 것이다

<br><br>

## 다중 인덱스 활용

다중 칼럼 인덱스에서 각 컬럼의 순서와 그 칼럼에 사용된 조건이 동등 비교인지 아니면 크다, 작다 같은 범위 조건인지에 따라 각 인덱스 컬럼의 활용 형태가 달라진다

```SQL
SELECT *
FROM dept_emp
WHERE dept_no='d001' AND emp_no>10000;
```

케이스 A: INDEX(dept_no, emp_no)
케이스 B: INDEX(emp_no, dept_no)

케이스 A의 경우 dept_no 컬럼이 먼저 오기 때문에 dept_no 컬럼의 값이 'd001'인 레코드만 읽어오고, 그 다음에 emp_no 컬럼의 값이 10000보다 큰 레코드만 읽어온다.

하지만 케이스 B의 경우 `emp_no>10000` 인 레코드를 찾고, 그 이후 모든 레코드에 대해  `dept_no='d001` 인지 비교하는 과정을 거쳐야 한다.

A 인덱스의 두 조건과 같이 작업 범위를 결정하는 조건을 `작업 범위 결정 조건` 이라 하고, B 케이스의 dept_no='d001' 과 같이 비교 작업의 범위를 줄이지 못하고 단순히 거름종이 역할만 하는 조건을 필터링 조건이라고 한다.

케이스 A 인덱스에서 dept_no 컬럼과 emp_no 컬럼은 모두 작업 범위 결정 조건에 해당하지만, 케이스 B는 emp_no 만 해당된다.

**작업 범위를 결정하는 조건이 많으면 쿼리의 처리 성능을 높이지만 필터링 조건이 많으면 오히려 성능을 떨어뜨린다.**

<br><br>

## 인덱스 가용성과 효율성 판단

**아래 조건은 작업 범위 결정 조건으로 사용할 수 없다.**

- NOT-EQUAL 조건 (ex: `<>`, NOT IN, NOT BETWEEN, IS NOT NULL)
  - `WHERE column <> 'N'`
  - `WHERE column NOT IN (10,11,12)`
  - `WHERE column IS NOT NULL`
- LIKE '%??' (앞부분이 아닌 뒷부분 일치 형태로 문자열 패턴 비교)
  - `WHERE column LIKE '%abc'`
  - `WHERE column LIKE '%abc%'`
  - `WHERE column LIKE '_abc%'`
- 스토어드 함수나 다른 연산자로 인덱스 칼럼이 변형된 후 비교
  - `WHERE SUBSTRING(column,1,1)='X'`
  - `WHERE DAYMONTH(column) = 1`
- NOT-DETERMINISTIC 스토어드 함수
  - `WHERE column = determinstic_func()`
- 데이터 타입이 서로 다른 비교
  - `WHERE char_column = 10`
- 문자열 데이터 타입의 콜레이션이 다른 경우
  - `WHERE utf8_column = latin1_column`

다중 컬럼으로 만들어진 인덱스에서 아래와 같은 상황은 인덱스를 사용하지 못한다

`IDX idx(column1, column2, ... , columnN)`

- `column_1` 컬럼에 대한 조건이 없는 경우
- `column_1` 컬럼에 대한 비교 조건이 위의 인덱스 사용 불가 조건 중 하나인 경우

<br><br>

## 클러스터링 인덱스

- InnoDB 스토리지 엔진에서만 지원하며 나머지 스토리지 엔진에서는 지원하지 않음
- 클러스터링 인덱스는 테이블의 프라이머리 키에 대해서만 적용됨
  - 즉, 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터링 인덱스라고 함
- **프라이머리 키 값에 의해 레코드 저장 위치가 결정된다**
  - 프라이머리 키 값이 변경되면 그 레코드의 물리적인 저장 위치가 바뀌어야 한다
- **클러스터링 인덱스의 리프 노드에는 레코드의 모든 칼럼이 같이 저장되어 있음**
- **모든 세컨더리 인덱스는 PK를 포함하고 있음**
  - 세컨더리 인덱스를 통해 검색할 때는 PK를 통해 다시 한 번 검색해야 한다.

> InnoDB 테이블에서 프라이머리 키가 없는 테이블은 어떻게 클러스터링 테이블로 구성할까?
> 1. PK가 있으면 PK를 클러스터링 키로 선택
> 2. 없으면 NOT NULL 옵션의 유니크 인덱스 중 첫번째 인덱스를 키로 선택
> 3. 유니크 인덱스가 없으면 자동으로 유니크한 값을 가지도록 증가되는 컬럼을 내부적으로 추가한 후, 키로 선택

<br>

### 클러스터링 인덱스 장점/단점

- 장점
  - PK로 범위 검색할 때  빠름
  - 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많음
- 단점
  - **클러스터링 키 값이 클 경우 세컨더리 인덱스 크기가 커짐**
  - 세컨더리 인덱스를 통해 검색할 때 PK로 다시 한 번 검색해야 함
  - 인서트할 때 PK에 의해 레코드 저장 위치가 결정되기 때문에 처리 성능이 느림
  - PK를 변경할 때 레코드 삭제 한 후 인서트하기 때문에 처리 성능이 느림

<br><br>

## 유니크 인덱스

- **유니크 인덱스와 유니크 하지 않은 일반 세컨더리 인덱스는 인덱스 구조상 아무런 차이가 없다**
- 차이는 1개의 레코드를 읽냐 2개 이상의 레코드를 읽냐 차이다. 읽어야할 레코드 건수가 같다면 성능상의 차이는 미미하다.
- 유니크 인덱스에서 중복된 값을 체크할 때는 읽기 잠금을 사용하고, 쓰기를 할 때는 쓰기 잠금을 사용한다.


### 인덱스 쓰기

- 유니크 인덱스의 키 값을 쓸떄는 중복된 값 체크하는 과정이 한 단계 더 필요하다
  - 그래서 유니크하지 않은 일반 세컨더리 인덱스보다 쓰기 성능이 떨어진다.
- 쓰기 과정에서 쓰기 잠금 때문에 아주 빈번히 데드락이 발생한다
- InnoDB 에서는 인덱스 변경 작업을 체인지 버퍼로 지연 처리 하는데, 유니크 인덱스는 반드시 중복 체크를 해야하기 때문에 지연 처리를 하지 못한다


<br><br>

## 외래키

- MySQL에서 외래키는 InnoDB 스토리지 엔진에서만 생성할 수 있고, **외래키 제약이 설정되면 자동으로 연관되는 테이블의 칼럼에 인덱스까지 생성된다.**
  - 외래키가 제거되지 않은 상태에서는 자동으로 생성된 인덱스를 삭제할 수 없다.
- 테이블 변경(쓰기 잠금)이 발생하는 경우에만 잠금 경합(잠금 대기)가 발생한다
- 외래키와 연관되지 않은 칼럼의 변경은 최대한 잠금 경합(잠금 대기)를 발생시키지 않는다.
